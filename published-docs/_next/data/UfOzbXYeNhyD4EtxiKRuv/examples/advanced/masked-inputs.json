{"pageProps":{"sourceCode":"import React, { ChangeEvent } from \"react\";\nimport { TransformationSchema, useDumbForm, ValidationError, ValidationSchema } from \"react-dumb-form\";\n\n// UI for documentation only\nimport { Form } from \"react-bootstrap\";\nimport { FormGroupTitle, FormTextInput } from \"ui/forms\";\nimport { FormTextInputCustom } from \"ui/forms/FormTextInputCustom\";\nimport Separator from \"ui/Separator\";\nimport Tip from \"ui/Tip\";\n\n// FORM SETUP AND TRANSFORMATION\n// --------------------------------------------------------------------------------\n\nconst defaultValues = {\n  valueOnlyAToF: \"\",\n  valueWithUnderscores: \"\",\n  valueUppercase: \"\",\n  creditCardInput: \"\",\n};\ntype Form = typeof defaultValues;\n\nconst customValueTransformations: Partial<Record<keyof Form, (value: unknown) => any>> = {\n  valueOnlyAToF: value => String(value).replaceAll(/[^a-f]*/g, \"\"),\n  valueWithUnderscores: value => String(value).replaceAll(/\\s/g, \"_\"),\n  valueUppercase: value => String(value).toUpperCase(),\n};\n\nconst CREDIT_CARD_MASK = \"____ ____ ____ ____\";\n\n// COMPONENT\n// --------------------------------------------------------------------------------\n\nexport function ExampleMaskedInputs() {\n  const [data, setData] = React.useState<Form & { [key: string]: any }>(defaultValues);\n\n  const { formProps, names, setValues } = useDumbForm<Form>({\n    name: \"example-masked-inputs-form\",\n    defaultValues,\n    onSubmit: setData,\n    onChange: setData,\n  });\n\n  const handleMaskedInputChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const { name, value } = event.target;\n    // Re-use the transformator and leave it in place in case of user error\n    const transformator = customValueTransformations[name as keyof Form];\n    if (!transformator) return;\n    setValues({ [name]: transformator(value) });\n  };\n\n  // WARNING: In production usage, you should use a masking library or a more general-purpose function\n  const handleCreditCardChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const input = event.target;\n    const name = names.creditCardInput;\n    const previousValue = data.creditCardInput.replaceAll(/[^0-9]/g, \"\");\n    const value = input.value.replaceAll(/[^0-9]/g, \"\");\n\n    let iVal = 0;\n    let iPat = 0;\n    let formattedValue = \"\";\n    let specialChars = \"\";\n    let cursorPos = Math.min(value.length, Number(input.selectionStart));\n\n    while (iVal < value.length && iPat < CREDIT_CARD_MASK.length) {\n      const charVal = value.charAt(iVal);\n      const charPat = CREDIT_CARD_MASK.charAt(iPat);\n      const isSameSpecialChar = charVal === charPat && charVal !== \"_\";\n\n      if (isSameSpecialChar || (charVal.match(/[0-9]/) && charPat === \"_\")) {\n        formattedValue += specialChars + charVal;\n        specialChars = \"\";\n        iVal++;\n        iPat++;\n      } else if (charPat !== \"_\") {\n        specialChars += charPat;\n        iPat++;\n        if (previousValue.length < value.length) cursorPos++;\n      } else {\n        break;\n      }\n    }\n\n    // Apply formatted value\n    setValues({ [name]: formattedValue });\n\n    // Update input value - input value does not reflect value stored in form state, it includes the rest of the mask\n    input.value = `${formattedValue}${\n      formattedValue.length !== CREDIT_CARD_MASK.length\n        ? CREDIT_CARD_MASK.slice(formattedValue.length - CREDIT_CARD_MASK.length)\n        : \"\"\n    }`;\n    input.setSelectionRange(cursorPos, cursorPos);\n  };\n\n  return (\n    <form {...formProps}>\n      <FormGroupTitle>Transform input value (controlled)</FormGroupTitle>\n      <FormTextInputCustom\n        label=\"Only allow [a-f] characters\"\n        onChange={handleMaskedInputChange}\n        name={names.valueOnlyAToF}\n        value={data.valueOnlyAToF}\n        small\n      />\n      <FormTextInputCustom\n        label=\"Replace spaces with underscores\"\n        onChange={handleMaskedInputChange}\n        name={names.valueWithUnderscores}\n        value={data.valueWithUnderscores}\n        small\n      />\n      <FormTextInputCustom\n        label=\"Convert to uppercase\"\n        onChange={handleMaskedInputChange}\n        name={names.valueUppercase}\n        value={data.valueUppercase}\n        small\n      />\n\n      <Separator dashed />\n\n      <FormGroupTitle>Masked credit card input</FormGroupTitle>\n      <FormTextInputCustom\n        label=\"Credit card number\"\n        onChange={handleCreditCardChange}\n        name={names.creditCardInput}\n        placeholder={CREDIT_CARD_MASK}\n      />\n      <Tip variant=\"danger\">\n        <strong>Warning: </strong> This implementation of a masked input is <strong>very naive</strong> and should serve\n        solely as a demonstration of possibility. In production, be sure to use more suitable solutions.\n      </Tip>\n    </form>\n  );\n}\n"},"__N_SSG":true}